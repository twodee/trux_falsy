<!DOCTYPE html>
<html>
<head>
  <title>Trux Falsy</title>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <script src="jquery.balloon.min.js"></script>
  <script src="levels.js"></script>
  <script>
var isShown = false;
var pendingMessage = null;

function showBalloon(msg) {
  if (isShown) {
    pendingMessage = msg;
    hideBalloon();
  } else {
    $('#guess').showBalloon({
      position: "bottom",
      tipSize: 10,
      html: true,
      minLifetime: 0,
      hideComplete: function() {
        if (pendingMessage != null) {
          showBalloon(pendingMessage);
          pendingMessage = null;
        }
      },
      css: {
        fontSize: '18pt',
        fontFamily: 'sans-serif',
        width: 1000,
      },
      contents: msg,
    });

    isShown = true;
  }
}

function hideBalloon() {
  $('#guess').hideBalloon();
  isShown = false;
}

var intro = [
  {selector: 'body', message: 'Welcome to Trux Falsy, a game where Space and Logic marry and have somewhere between 0 and 100 kids. You, a gene therapist, will help them have the ones they want. Click in this box to proceed.'},
  {selector: '#expectedGrid', message: 'On the left you see the kids they want to have. They are brightly colored. Each lives at a particular two-dimensional location.'},
  {selector: '#bookmark82', message: 'For example, this kid lives at x == 2, y == 8.'},
  {selector: '#actualGrid', message: 'On the right are the kids that will actually be born given the couple\'s current Genetic Expression.'},
  {selector: '#guess', message: 'In the box above, enter a Genetic Expression using the language of logic&mdash;that is, in terms of <code>x</code>, <code>y</code>, and various operators that you will learn about. Express x and y values only for the kids shown in Expected. For example, <code>y &gt;= 8</code> causes the top two rows to be born. Operators <code>&lt;</code>, <code>&lt;=</code>, and <code>&gt;</code> are also available.'},
];
var ii = 0;

function advanceIntro() {
  if (ii > 0) {
    $(intro[ii].selector).hideBalloon();
  }

  var offsetX = 0;
  var offsetY = 0;
  var position = "bottom";
  var width = 0;

  if (ii == 0) {
    width = 500;
    position = null;
  } else if (ii == 2) {
    width = 250;
  } else {
    width = $(intro[ii].selector).width();
  }

  if (ii == intro.length - 1) {
    showBalloon(intro[ii].message);
  } else {
    $(intro[ii].selector).showBalloon({
      position: position,
      offsetX: offsetX,
      offsetY: offsetY,
      tipSize: ii == 0 ? 0 : 10,
      html: true,
      minLifetime: 0,
      hideComplete: function() {
        ++ii;
        advanceIntro();
      },
      css: {
        fontSize: '18pt',
        fontFamily: 'sans-serif',
        width: width
      },
      classname: 'balloon',
      contents: localize(intro[ii].message),
    });
  }

  if (ii < intro.length - 1) {
    $('.balloon').on('click', function() {
      $(intro[ii].selector).hideBalloon();
    });
  } else {
    $('.balloon').off('click');
    document.getElementById('guess').focus();
  }
}

$(document).ready(function() {
  load();
  var node82 = document.getElementById('expectedBottom82');
  var rect = node82.getBoundingClientRect();

  var bookmark82 = document.getElementById('bookmark82');
  bookmark82.style.position = 'absolute';
  bookmark82.style.left = rect.left + 'px';
  bookmark82.style.top = (rect.top + window.scrollY) + 'px';
  bookmark82.style.width = rect.width + 'px';
  bookmark82.style.height = rect.height + 'px';
  
  advanceIntro();
});
  </script>
  <style>

#levelName {
  font-size: 24pt;
  font-family: sans-serif;
  text-align: center;
}

.gridtitle {
  font-size: 24pt;
  font-family: sans-serif;
}

.gridpanel {
  text-align: center;
}

#main {
  clear: both;
  margin-left: auto;
  margin-right: auto;
  width: 1000px;
}

.grid {
  width: 450px;
  height: 450px;
  text-align: center;
}

#info {
  margin-left: auto;
  margin-right: auto;
  font-size: 18pt;
  margin-bottom: 10px;
}

#guess {
  clear: both;
  width: 100%;
  font-size: 24px;
  font-family: 'Courier';
}

#percentage {
  float: right;
  color: red;
  font-size: 14px;
  margin-bottom: 5px;
  margin-right: 0px;
}
  </style>
</head>
<body>

<div id="bookmark82"></div>

<div id="main">
  <h1 id="levelName" style="clear: both">Level Name</h1>

  <div style="clear: both">
    <div class="gridpanel" style="float: left">
      <span class="gridtitle">Expected</span><br/>
      <svg id="expectedGrid" class="grid"></svg>
    </div>
    <div class="gridpanel" style="float: right">
      <span class="gridtitle">Actual</span><br/>
      <svg id="actualGrid" class="grid"></svg>
    </div>
  </div>

  <span style="clear:both" id="percentage">&nbsp;</span>
  <input id="guess" type="text" oninput="showGuess()"></input><br/>
</div>

<script>
var andToken = '&&';
var orToken = '||';
var notToken = '!';
var absToken = 'abs';
var maxToken = 'max';
var minToken = 'min';

//var andToken = 'and';
//var orToken = 'or';
//var notToken = 'not';

var topTrueColor =  'hsl(306, 100%, 74%)';
var bottomTrueColor = 'hsl(306, 100%, 64%)';
var topFalseColor = 'hsl(0, 0%, 90%)';
var bottomFalseColor = 'hsl(0, 0%, 85%)';

var OPEN = 0;
var CLOSE = 1;
var X = 2;
var Y = 3;
var XOR = 4;
var AND = 5;
var OR = 6;
var EQUALS = 7;
var NOT_EQUALS = 8;
var GREATER_THAN = 9;
var GREATER_THAN_EQUALS = 10;
var LESS_THAN = 11;
var LESS_THAN_EQUALS = 12;
var NOT = 13;
var INTEGER = 14;
var EOF = 15;
var ADD = 16;
var MULTIPLY = 18;
var DIVIDE = 19;
var REMAINDER = 20;
var MINUS = 21;
var LITERAL_TRUE = 22;
var LITERAL_FALSE = 23;
var ABSOLUTE_VALUE = 24;
var BITWISE_AND = 25;
var BITWISE_OR = 26;
var MAX = 27;
var MIN = 28;
var COMMA = 29;

function escapeRegexWildcards(s) {
  return s.replace(/([-.?*+$\[\]\/\\(){}|])/g, '\\$1');
}

function localize(s) {
  return s.replace(/AND/g, andToken).replace(/OR/g, orToken).replace(/NOT/g, notToken);
}

function Token(type, text, startIndex, endIndex) {
  this.type = type;
  this.text = text;
  this.startIndex = startIndex;
  this.endIndex = endIndex;
  return this;
}

function Lexer(src) {
  this.src = src;
  this.i = 0;
  this.soFar = '';
  this.soFarStartedAt;

  this.getToken = function() {

    // Skip over whitespace.
    while (this.i < this.src.length && this.src.charAt(this.i) == ' ') {
      ++this.i;
    }

    this.soFarStartedAt = this.i;
    var left = this.src.substr(this.i);

    if (this.i >= src.length) {
      return new Token(EOF, 'the end of your input', src.length, src.length); 
    } else if (left.match(/^true/)) {
      this.i += 4;
      return new Token(LITERAL_TRUE, 'true', this.soFarStartedAt, this.i);
    } else if (left.match(/^false/)) {
      this.i += 5;
      return new Token(LITERAL_FALSE, 'false', this.soFarStartedAt, this.i);
    } else if (left.match(new RegExp('^' + escapeRegexWildcards(absToken)))) {
      this.i += absToken.length;
      return new Token(ABSOLUTE_VALUE, absToken, this.soFarStartedAt, this.i);
    } else if (left.match(new RegExp('^' + escapeRegexWildcards(maxToken)))) {
      this.i += maxToken.length;
      return new Token(MAX, maxToken, this.soFarStartedAt, this.i);
    } else if (left.match(new RegExp('^' + escapeRegexWildcards(minToken)))) {
      this.i += minToken.length;
      return new Token(MIN, minToken, this.soFarStartedAt, this.i);
    } else if (left.match(/^,/)) {
      ++this.i;
      return new Token(COMMA, ',', this.soFarStartedAt, this.i);
    } else if (left.match(/^-/)) {
      ++this.i;
      return new Token(MINUS, '-', this.soFarStartedAt, this.i);
    } else if (left.match(/^x/)) {
      ++this.i;
      return new Token(X, 'x', this.soFarStartedAt, this.i);
    } else if (left.match(/^y/)) {
      ++this.i;
      return new Token(Y, 'y', this.soFarStartedAt, this.i);
    } else if (left.match(/^\(/)) {
      ++this.i;
      return new Token(OPEN, '(', this.soFarStartedAt, this.i);
    } else if (left.match(/^\)/)) {
      ++this.i;
      return new Token(CLOSE, ')', this.soFarStartedAt, this.i);
    } else if (left.match(/^!=/)) {
      this.i += 2;
      return new Token(NOT_EQUALS, '!=', this.soFarStartedAt, this.i);
    } else if (left.match(new RegExp('^' + escapeRegexWildcards(notToken)))) {
      this.i += notToken.length;
      return new Token(NOT, notToken, this.soFarStartedAt, this.i);
    } else if (left.match(/^\*/)) {
      ++this.i;
      return new Token(MULTIPLY, '*', this.soFarStartedAt, this.i);
    } else if (left.match(/^\//)) {
      ++this.i;
      return new Token(DIVIDE, '\/', this.soFarStartedAt, this.i);
    } else if (left.match(/^%/)) {
      ++this.i;
      return new Token(REMAINDER, '%', this.soFarStartedAt, this.i);
    } else if (left.match(/^\+/)) {
      ++this.i;
      return new Token(ADD, '+', this.soFarStartedAt, this.i);
    } else if (left.match(/^\^/)) {
      ++this.i;
      return new Token(XOR, '^', this.soFarStartedAt, this.i);
    } else if (left.match(/^<=/)) {
      this.i += 2;
      return new Token(LESS_THAN_EQUALS, '<=', this.soFarStartedAt, this.i);
    } else if (left.match(/^</)) {
      ++this.i;
      return new Token(LESS_THAN, '<', this.soFarStartedAt, this.i);
    } else if (left.match(/^>=/)) {
      this.i += 2;
      return new Token(GREATER_THAN_EQUALS, '>=', this.soFarStartedAt, this.i);
    } else if (left.match(/^>/)) {
      ++this.i;
      return new Token(GREATER_THAN, '>', this.soFarStartedAt, this.i);
    } else if (left.match(new RegExp('^' + escapeRegexWildcards(andToken)))) {
      this.i += andToken.length;
      return new Token(AND, andToken, this.soFarStartedAt, this.i);
    } else if (left.match(new RegExp('^' + escapeRegexWildcards(orToken)))) {
      this.i += orToken.length;
      return new Token(OR, orToken, this.soFarStartedAt, this.i);
    } else if (left.match(/^&/)) {
      ++this.i;
      return new Token(BITWISE_AND, '&', this.soFarStartedAt, this.i);
    } else if (left.match(/^\|/)) {
      ++this.i;
      return new Token(BITWISE_OR, '|', this.soFarStartedAt, this.i);
    } else if (left.match(/^==/)) {
      this.i += 2;
      return new Token(EQUALS, '==', this.soFarStartedAt, this.i);
    } else if (result = left.match(/^(-?\d+)/)) {
      this.i += result[1].length;
      return new Token(INTEGER, parseInt(result[1]), this.soFarStartedAt, this.i);
    }

    throw "I'm sorry. I don't know about " + this.src.charAt(this.i) + '.';
  }

  this.lex = function() {
    var tokens = [];

    var token;
    do {
      token = this.getToken();
      tokens.push(token);
    } while (token.type != EOF);

    return tokens;
  }

  return this;
}

function ExpressionOr(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isBoolean) throw '<code>OR</code> expects boolean operands.';
    if (!rr.isBoolean) throw '<code>OR</code> expects boolean operands.';
    return new ExpressionBoolean(ll.toBoolean() || rr.toBoolean());
  }
}

function ExpressionAnd(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isBoolean) throw '<code>AND</code> expects boolean operands.';
    if (!rr.isBoolean) throw '<code>AND</code> expects boolean operands.';
    return new ExpressionBoolean(ll.toBoolean() && rr.toBoolean());
  }
}

function ExpressionBitwiseOr(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>|</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>|</code> expects integer operands.';
    return new ExpressionInteger(ll.toInteger() | rr.toInteger());
  }
}

function ExpressionBitwiseAnd(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>&</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>&</code> expects integer operands.';
    return new ExpressionInteger(ll.toInteger() & rr.toInteger());
  }
}

function ExpressionXor(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (ll.isInteger && rr.isInteger) {
      return new ExpressionInteger(ll.toInteger() ^ rr.toInteger());
    } else if (ll.isBoolean && rr.isBoolean) {
      return new ExpressionBoolean(ll.toBoolean() != rr.toBoolean());
    } else {
      throw '<code>^</code> expects its operands to have the same type.';
    }
  }
}

function ExpressionNot(r) {
  this.r = r;
  this.evaluate = function(env) {
    var rr = r.evaluate(env); 
    if (!rr.isBoolean) throw '<code>NOT</code> expects boolean operands.';
    return new ExpressionBoolean(!rr.toBoolean());
  }
}

function ExpressionAbs(r) {
  this.r = r;
  this.evaluate = function(env) {
    var rr = r.evaluate(env); 
    if (!rr.isInteger) throw '<code>ABS</code> expects integer operands.';
    return new ExpressionInteger(Math.abs(rr.toInteger()));
  }
}

function ExpressionMax(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>max</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>max</code> expects integer operands.';
    return new ExpressionInteger((ll.toInteger() > rr.toInteger()) ? ll.toInteger() : rr.toInteger());
  }
}

function ExpressionMin(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>min</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>min</code> expects integer operands.';
    return new ExpressionInteger((ll.toInteger() < rr.toInteger()) ? ll.toInteger() : rr.toInteger());
  }
}

function ExpressionEquals(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (ll.isInteger && rr.isInteger) {
      return new ExpressionBoolean(ll.toInteger() == rr.toInteger());
    } else if (ll.isBoolean && rr.isBoolean) {
      return new ExpressionBoolean(ll.toBoolean() == rr.toBoolean());
    } else {
      throw '<code>==</code> expects its operands to have the same type.';
    }
  }
}

function ExpressionNotEquals(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (ll.isInteger && rr.isInteger) {
      return new ExpressionBoolean(ll.toInteger() != rr.toInteger());
    } else if (ll.isBoolean && rr.isBoolean) {
      return new ExpressionBoolean(ll.toBoolean() != rr.toBoolean());
    } else {
      throw '<code>!=</code> expects its operands to have the same type.';
    }
  }
}

function ExpressionGreaterThan(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>&gt;</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>&gt;</code> expects integer operands.';
    return new ExpressionBoolean(ll.toInteger() > rr.toInteger());
  }
}

function ExpressionGreaterThanEquals(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>&gt;=</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>&gt;=</code> expects integer operands.';
    return new ExpressionBoolean(ll.toInteger() >= rr.toInteger());
  }
}

function ExpressionLessThan(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>&lt;</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>&lt;</code> expects integer operands.';
    return new ExpressionBoolean(ll.toInteger() < rr.toInteger());
  }
}

function ExpressionLessThanEquals(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>&lt;=</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>&lt;=</code> expects integer operands.';
    return new ExpressionBoolean(ll.toInteger() <= rr.toInteger());
  }
}

function ExpressionAdd(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>+</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>+</code> expects integer operands.';
    return new ExpressionInteger(ll.toInteger() + rr.toInteger());
  }
}

function ExpressionSubtract(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>-</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>-</code> expects integer operands.';
    return new ExpressionInteger(ll.toInteger() - rr.toInteger());
  }
}

function ExpressionMultiply(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>*</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>*</code> expects integer operands.';
    return new ExpressionInteger(ll.toInteger() * rr.toInteger());
  }
}

function ExpressionDivide(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>/</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>/</code> expects integer operands.';
    return new ExpressionInteger(ll.toInteger() / rr.toInteger());
  }
}

function ExpressionRemainder(l, r) {
  this.l = l;
  this.r = r;
  this.evaluate = function(env) {
    var ll = l.evaluate(env); 
    var rr = r.evaluate(env); 
    if (!ll.isInteger) throw '<code>%</code> expects integer operands.';
    if (!rr.isInteger) throw '<code>%</code> expects integer operands.';
    return new ExpressionInteger(ll.toInteger() % rr.toInteger());
  }
}

function ExpressionNegative(r) {
  this.r = r;
  this.evaluate = function(env) {
    var rr = r.evaluate(env); 
    if (!rr.isInteger) throw '<code>-</code> exprects an integer operand.';
    return new ExpressionInteger(-rr);
  }
}

function ExpressionInteger(value) {
  this.value = parseInt(value);

  this.evaluate = function(env) {
    return this;
  }

  this.isBoolean = false;
  this.isInteger = true;

  this.toInteger = function() {
    return value;
  }
}

function ExpressionX() {
  this.evaluate = function(env) {
    return new ExpressionInteger(env.x);
  }
}

function ExpressionY() {
  this.evaluate = function(env) {
    return new ExpressionInteger(env.y);
  }
}

function ExpressionBoolean(value) {
  this.value = value;

  this.evaluate = function(env) {
    return this;
  }

  this.isBoolean = true;
  this.isInteger = false;

  this.toBoolean = function() {
    return value;
  }
}

function Parser(tokens) {
  this.tokens = tokens;

  this.parse = function() {
    this.expressions = [];
    this.i = 0;
    this.expressionOr();
    if (this.expressions.length == 0) {
      return null;
    } else if (this.tokens[this.i].type != EOF) {
      throw 'I thought your expression was complete, but then I found a stray ' + this.tokens[this.i].text + '.';
    } else if (this.expressions.length == 1) {
      return this.expressions.pop();
    } else {
      throw 'too many!';
    }
  }

  this.expressionOr = function() {
    this.expressionAnd();
    while (this.isUp(OR)) {
      ++this.i;
      this.expressionAnd();
      var r = this.expressions.pop(); 
      var l = this.expressions.pop(); 
      this.expressions.push(new ExpressionOr(l, r));
    }
  }

  this.expressionAnd = function() {
    this.expressionBitwiseOr();
    while (this.isUp(AND)) {
      ++this.i;
      this.expressionBitwiseOr();
      var r = this.expressions.pop(); 
      var l = this.expressions.pop(); 
      this.expressions.push(new ExpressionAnd(l, r));
    }
  }

  this.expressionBitwiseOr = function() {
    this.expressionXor();
    while (this.isUp(BITWISE_OR)) {
      ++this.i;
      this.expressionXor();
      var r = this.expressions.pop(); 
      var l = this.expressions.pop(); 
      this.expressions.push(new ExpressionBitwiseOr(l, r));
    }
  }

  this.expressionXor = function() {
    this.expressionBitwiseAnd();
    while (this.isUp(XOR)) {
      ++this.i;
      this.expressionBitwiseAnd();
      var r = this.expressions.pop(); 
      var l = this.expressions.pop(); 
      this.expressions.push(new ExpressionXor(l, r));
    }
  }

  this.expressionBitwiseAnd = function() {
    this.expressionEqual();
    while (this.isUp(BITWISE_AND)) {
      ++this.i;
      this.expressionEqual();
      var r = this.expressions.pop(); 
      var l = this.expressions.pop(); 
      this.expressions.push(new ExpressionBitwiseAnd(l, r));
    }
  }

  this.expressionEqual = function() {
    this.expressionRelational();
    while (this.isUp(EQUALS) || this.isUp(NOT_EQUALS)) {
      var type = this.tokens[this.i].type;
      ++this.i;
      this.expressionRelational();
      var r = this.expressions.pop(); 
      var l = this.expressions.pop(); 
      if (type == EQUALS) {
        this.expressions.push(new ExpressionEquals(l, r));
      } else {
        this.expressions.push(new ExpressionNotEquals(l, r));
      }
    }
  }

  this.expressionRelational = function() {
    this.expressionAdditive();
    while (this.isUp(GREATER_THAN) || this.isUp(GREATER_THAN_EQUALS) || this.isUp(LESS_THAN) || this.isUp(LESS_THAN_EQUALS)) {
      var type = this.tokens[this.i].type;
      ++this.i;
      this.expressionAdditive();
      var r = this.expressions.pop(); 
      var l = this.expressions.pop(); 
      if (type == GREATER_THAN) {
        this.expressions.push(new ExpressionGreaterThan(l, r));
      } else if (type == GREATER_THAN_EQUALS) {
        this.expressions.push(new ExpressionGreaterThanEquals(l, r));
      } else if (type == LESS_THAN) {
        this.expressions.push(new ExpressionLessThan(l, r));
      } else {
        this.expressions.push(new ExpressionLessThanEquals(l, r));
      }
    }
  }

  this.expressionAdditive = function() {
    this.expressionMultiplicative();
    while (this.isUp(ADD) || this.isUp(MINUS)) {
      var type = this.tokens[this.i].type;
      ++this.i;
      this.expressionMultiplicative();
      var r = this.expressions.pop(); 
      var l = this.expressions.pop(); 
      if (type == ADD) {
        this.expressions.push(new ExpressionAdd(l, r));
      } else {
        this.expressions.push(new ExpressionSubtract(l, r));
      }
    }
  }

  this.expressionMultiplicative = function() {
    this.expressionNegative();
    while (this.isUp(MULTIPLY) || this.isUp(DIVIDE) || this.isUp(REMAINDER)) {
      var type = this.tokens[this.i].type;
      ++this.i;
      this.expressionNegative();
      var r = this.expressions.pop(); 
      var l = this.expressions.pop(); 
      if (type == MULTIPLY) {
        this.expressions.push(new ExpressionMultiply(l, r));
      } else if (type == DIVIDE) {
        this.expressions.push(new ExpressionDivide(l, r));
      } else {
        this.expressions.push(new ExpressionRemainder(l, r));
      }
    }
  }

  this.expressionNegative = function() {
    if (this.isUp(MINUS)) {
      ++this.i;
      this.expressionAtom();
      var r = this.expressions.pop(); 
      this.expressions.push(new ExpressionNegative(r));
    } else if (this.isUp(NOT)) {
      ++this.i;
      this.expressionAtom();
      var r = this.expressions.pop(); 
      this.expressions.push(new ExpressionNot(r));
    } else if (this.isUp(ABSOLUTE_VALUE)) {
      ++this.i;
      this.expressionAtom();
      var r = this.expressions.pop(); 
      this.expressions.push(new ExpressionAbs(r));
    } else if (this.isUp(MAX) || this.isUp(MIN)) {
      var isMin = this.isUp(MIN);

      ++this.i;
      if (this.isUp(OPEN)) {
        ++this.i;
      } else {
        throw 'I expected (.';
      }
      this.expressionOr();
      if (this.isUp(COMMA)) {
        ++this.i;
      } else {
        throw 'I expected ,.';
      }
      this.expressionOr();
      if (this.isUp(CLOSE)) {
        ++this.i;
      } else {
        throw 'I expected ).';
      }

      var r = this.expressions.pop(); 
      var l = this.expressions.pop(); 

      if (isMin) {
        this.expressions.push(new ExpressionMin(l, r));
      } else {
        this.expressions.push(new ExpressionMax(l, r));
      }
    } else {
      this.expressionAtom();
    }
  }

  this.expressionAtom = function() {
    if (this.isUp(X)) {
      ++this.i;
      this.expressions.push(new ExpressionX());
    } else if (this.isUp(LITERAL_TRUE)) {
      ++this.i;
      this.expressions.push(new ExpressionBoolean(true));
    } else if (this.isUp(LITERAL_FALSE)) {
      ++this.i;
      this.expressions.push(new ExpressionBoolean(false));
    } else if (this.isUp(Y)) {
      ++this.i;
      this.expressions.push(new ExpressionY());
    } else if (this.isUp(INTEGER)) {
      this.expressions.push(new ExpressionInteger(parseInt(this.tokens[this.i].text)));
      ++this.i;
    } else if (this.isUp(OPEN)) {
      ++this.i;
      this.expressionOr();
      if (this.isUp(CLOSE)) {
        ++this.i;
      } else {
        throw 'missing right';
      }
    } else {
      throw 'Whoa. I ran into ' + this.tokens[this.i].text + ' and really didn\'t expect that.';
    }
  }

  this.isUp = function(expected) {
    return this.i < this.tokens.length && this.tokens[this.i].type == expected;
  }
}

document.getElementById('guess').onkeypress = function(e) {
  if (!e) e = window.event;
  var keyCode = e.keyCode || e.which;
  if (keyCode == '13' && nRight == 100) {
    next(); 
  }
}

var nRight = 0;

function showGuess() {
  var src = document.getElementById('guess').value;

  if (src == '') {
    document.getElementById('percentage').innerHTML = '&nbsp;';
    load();
    return;
  }
  nRight = 0;

  try {
    var lexer = new Lexer(src);
    var tokens = lexer.lex();
    var parser = new Parser(tokens);
    var ast = parser.parse();
    console.log(ast);

    for (var y = 0; y < 10; ++y) {
      for (var x = 0; x < 10; ++x) {
        var i = y * 10 + x;
        var actualTop = document.getElementById('actualTop' + i);    
        var actualBottom = document.getElementById('actualBottom' + i);    
        var result = ast.evaluate({'x': x, 'y': y});

        if (result.isBoolean) {
          if (result.toBoolean()) {
            actualTop.style.fill = topTrueColor;
            actualBottom.style.fill = bottomTrueColor;
          } else {
            actualTop.style.fill = topFalseColor;
            actualBottom.style.fill = bottomFalseColor;
          }
        } else {
          throw 'Your expression doesn\'t yield true or false.';
        }

        var wrong = document.getElementById('wrong' + i);    
        if (result.isBoolean && result.toBoolean() === leval(wi, li, x, y)) {
          wrong.style['stroke-opacity'] = 0.0;
          ++nRight;
        } else {
          wrong.style['stroke-opacity'] = 0.2;
        }
      }
    }

    document.getElementById('percentage').innerHTML = nRight + '/100 right';
    if (nRight == 100) {
      if (li == worlds[wi].levels.length - 1) {
        showBalloon(localize(worlds[wi].message));
      } else {
        showBalloon('Got \'em! Hit Enter for the next litter.');
      }
    }
  } catch (e) {
    document.getElementById('percentage').innerHTML = localize(e);
  }

  return true;
}

function next() {
  document.getElementById('percentage').innerHTML = '&nbsp;';
  if (li == worlds[wi].levels.length - 1) {
    wi = (wi + 1) % worlds.length;
    li = 0;
  } else {
    ++li;
  }
  document.getElementById('guess').value = ''; 
  load();
}

// Divide the grid up into 12 rows. The top 10 are for the tiles.
// The second-to-bottom is for the x tic marks. We don't allow
// these marks to be taller than the tiles. The bottom is the
// axis label.
var gridHeight = 450;
var tileDiameter = gridHeight / 12;
var tileRadius = tileDiameter * 0.5;
var strikeDiameter = 0.7 * tileDiameter;
var strikeSide = Math.sqrt(2 * Math.pow(strikeDiameter, 2)) * 0.5;
var strikeHalfSide = 0.5 * strikeSide;
var fontSizePixels = 0.5 * tileDiameter;

// Creates a text node whose pivot point/origin is in its center.
// This makes aligning it a bit easier.
function createTextNode(symbol, x, y) {
  var text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  text.setAttributeNS(null, 'font-size', fontSizePixels + 'px');
  text.setAttributeNS(null, 'font-family', 'monospace');
  text.setAttributeNS(null, 'fill', '#999999');
  text.setAttributeNS(null, 'alignment-baseline', 'central');
  text.setAttributeNS(null, 'text-anchor', 'middle');
  text.setAttributeNS(null, 'x', x);
  text.setAttributeNS(null, 'y', y);
  text.textContent = symbol;
  return text;
}

// Determine the size of a character. We will need these bounds to
// position the x and y tic marks.
var text = createTextNode('9', 0, 0);
document.getElementById('expectedGrid').appendChild(text);
var bbox = text.getBBox();
document.getElementById('expectedGrid').removeChild(text);

var charWidth = bbox.width;
var charHeight = bbox.height;
var leftMargin = 4 * charWidth;
var bottomMargin = 2 * tileDiameter;

for (var i = 0; i < 10; ++i) {
  var y = gridHeight - bottomMargin - i * tileDiameter - tileRadius;

  // Y labels.
  text = createTextNode('' + i, 2.5 * charWidth, y);
  document.getElementById('expectedGrid').appendChild(text);
  text = createTextNode('' + i, 2.5 * charWidth, y);
  document.getElementById('actualGrid').appendChild(text);

  // X labels.
  text = createTextNode('' + i, leftMargin + i * tileDiameter + tileRadius, gridHeight - tileDiameter - charHeight);
  document.getElementById('expectedGrid').appendChild(text);
  text = createTextNode('' + i, leftMargin + i * tileDiameter + tileRadius, gridHeight - tileDiameter - charHeight);
  document.getElementById('actualGrid').appendChild(text);
}

text = createTextNode('x', leftMargin + 4.5 * tileDiameter + tileRadius, gridHeight - charHeight * 1.5);
document.getElementById('expectedGrid').appendChild(text);
text = createTextNode('x', leftMargin + 4.5 * tileDiameter + tileRadius, gridHeight - charHeight * 1.5);
document.getElementById('actualGrid').appendChild(text);

text = createTextNode('y', charWidth * 0.5, gridHeight - bottomMargin - 4.5 * tileDiameter - tileRadius);
//text.setAttributeNS(null, 'transform', 'rotate(-90 ' + (charWidth * 0.5) + ' ' + (gridHeight - bottomMargin - 4.5 * tileDiameter - tileRadius) + ')');
document.getElementById('expectedGrid').appendChild(text);
text = createTextNode('y', charWidth * 0.5, gridHeight - bottomMargin - 4.5 * tileDiameter - tileRadius);
//text.setAttributeNS(null, 'transform', 'rotate(-90 ' + (charWidth * 0.5) + ' ' + (gridHeight - bottomMargin - 4.5 * tileDiameter - tileRadius) + ')');
document.getElementById('actualGrid').appendChild(text);

for (var y = 0; y < 10; ++y) {
  for (var x = 0; x < 10; ++x) {
    var i = y * 10 + x;

    var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttributeNS(null, 'id', 'expectedTop' + i);
    path.setAttributeNS(null, 'd', 'M' + (leftMargin + x * tileDiameter) + ',' + (gridHeight - bottomMargin - y * tileDiameter - tileRadius) + ' a' + tileRadius + ',' + tileRadius + ' 0, 0,1 ' + tileDiameter + ',0');
    path.style['stroke-width'] = 0;
    document.getElementById('expectedGrid').appendChild(path);

    path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttributeNS(null, 'id', 'expectedBottom' + i);
    path.setAttributeNS(null, 'd', 'M' + (leftMargin + x * tileDiameter) + ',' + (gridHeight - bottomMargin - y * tileDiameter - tileRadius) + ' a' + tileRadius + ',' + tileRadius + ' 0, 0,0 ' + tileDiameter + ',0');
    path.style['stroke-width'] = 0;
    document.getElementById('expectedGrid').appendChild(path);

    var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttributeNS(null, 'id', 'actualTop' + i);
    path.setAttributeNS(null, 'd', 'M' + (leftMargin + x * tileDiameter) + ',' + (gridHeight - bottomMargin - y * tileDiameter - tileRadius) + ' a' + tileRadius + ',' + tileRadius + ' 0, 0,1 ' + tileDiameter + ',0');
    path.style['stroke-width'] = 0;
    document.getElementById('actualGrid').appendChild(path);

    path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttributeNS(null, 'id', 'actualBottom' + i);
    path.setAttributeNS(null, 'd', 'M' + (leftMargin + x * tileDiameter) + ',' + (gridHeight - bottomMargin - y * tileDiameter - tileRadius) + ' a' + tileRadius + ',' + tileRadius + ' 0, 0,0 ' + tileDiameter + ',0');
    path.style['stroke-width'] = 0;
    document.getElementById('actualGrid').appendChild(path);

    wrong = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    wrong.setAttributeNS(null, 'id', 'wrong' + i);
    wrong.setAttributeNS(null, 'd', 'M' + (leftMargin + x * tileDiameter + tileRadius) + ',' + (gridHeight - bottomMargin - y * tileDiameter - tileRadius) + ' m' + -strikeHalfSide + ',' + -strikeHalfSide + ' l' + strikeSide + ',' + strikeSide + ' m' + -strikeHalfSide + ',' + -strikeHalfSide + ' m' + -strikeHalfSide + ',' + strikeHalfSide + ' l' + strikeSide + ',' + -strikeSide);
    wrong.style['stroke-width'] = 5;
    wrong.style.stroke = '#000000';
    document.getElementById('actualGrid').appendChild(wrong);
  }
}

function leval(wi, li, x, y) {
  return worlds[wi].levels[li].configuration.charAt(y * 10 + x) == '1';
}

var wi = 0;
var li = 0;

function load() {
  nRight = 0;
  document.getElementById('levelName').innerHTML = 'Generation ' + wi + ', Litter ' + li + ': ' + worlds[wi].levels[li].name;
  for (var y = 0; y < 10; ++y) {
    for (var x = 0; x < 10; ++x) {
      var i = y * 10 + x;
      var expectedTop = document.getElementById('expectedTop' + i);
      var expectedBottom = document.getElementById('expectedBottom' + i);
      var actualTop = document.getElementById('actualTop' + i);
      var actualBottom = document.getElementById('actualBottom' + i);
      if (leval(wi, li, x, y)) {
        expectedTop.style.fill = topTrueColor;
        expectedBottom.style.fill = bottomTrueColor;
      } else {
        expectedTop.style.fill = topFalseColor;
        expectedBottom.style.fill = bottomFalseColor;
      }
      actualTop.style.fill = topFalseColor;
      actualBottom.style.fill = bottomFalseColor;
      var wrong = document.getElementById('wrong' + i);
      wrong.style['stroke-opacity'] = 0;
    }
  }

  if (worlds[wi].levels[li].hasOwnProperty('message')) {
    showBalloon(localize(worlds[wi].levels[li].message));
  } else {
    hideBalloon();
  }
}
</script>

</body>
</html>
